/**
 * @fileoverview Firestore Security Rules for the Hagaaty AI Blog.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user profiles and campaigns,
 * and a public-read, admin-write model for articles, categories, and tags.
 * It includes specific, fine-grained logic for user point and balance management
 * to prevent unauthorized modifications.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // =================================================================
    //  Helper Functions
    // =================================================================

    /**
     * @description Checks if the request is from an authenticated user.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided user ID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is an admin.
     * Admins are identified by a 'role' field in their user profile document.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    /**
     * @description Validates the fields that can be changed during user signup.
     * Ensures all required fields are present and have the correct initial values.
     */
    function hasValidSignupFields() {
        let user = request.resource.data;
        // The 'referredBy' field is a referral *code*, not a UID. It's optional.
        let isReferredByValid = !('referredBy' in user) || user.referredBy == null || user.referredBy is string;
        // The 'ancestors' field must be a list (can be empty or populated by client logic).
        let isAncestorsValid = 'ancestors' in user && user.ancestors is list && user.ancestors.size() <= 5;
        
        return user.id == request.auth.uid
            && user.displayName is string
            && user.email == request.auth.token.email
            && (user.role == 'user' || (user.role == 'admin' && user.email == 'hagaaty@gmail.com'))
            && user.balance == 2.00
            && user.points == 0
            && user.lastMarketingTriggerAt == null
            && user.createdAt == request.time
            && user.referralCode is string
            && user.referralEarnings == 0
            && user.status == 'active'
            && isReferredByValid
            && isAncestorsValid
            && 'achievements' in user && user.achievements is list && user.achievements.size() == 0
            && user.isAgencyMember == false;
    }


    /**
     * @description Validates that immutable fields are not being changed by the user.
     */
    function hasAllowedUserUpdates(incoming, existing) {
        return incoming.id == existing.id
            && incoming.email == existing.email
            && incoming.role == existing.role
            && incoming.createdAt == existing.createdAt
            && incoming.referralCode == existing.referralCode
            // Users cannot change their own referral earnings or ancestors. Only system logic (via admin SDK) can.
            && incoming.referralEarnings == existing.referralEarnings
            && incoming.ancestors == existing.ancestors
            && incoming.referredBy == existing.referredBy // User cannot change who referred them
            && incoming.status == existing.status // User cannot change their own status
            && incoming.isAgencyMember == existing.isAgencyMember; // User cannot change their agency status
    }
    
    /**
     * @description Admin-only updates to a user profile.
     */
    function hasAllowedAdminUpdates(incoming, existing) {
        // Admin can change displayName, balance, and status. All other fields are protected from manual admin change
        // to ensure integrity (e.g. points/referrals should only be changed by system logic).
        return incoming.id == existing.id
            && incoming.email == existing.email
            && incoming.role == existing.role // Admins cannot change roles
            && incoming.createdAt == existing.createdAt
            && incoming.referralCode == existing.referralCode
            && incoming.referralEarnings == existing.referralEarnings // Only system logic can change this
            && incoming.referredBy == existing.referredBy
            && incoming.ancestors == existing.ancestors
            && incoming.points == existing.points // Only system logic can change this
            && incoming.lastMarketingTriggerAt == existing.lastMarketingTriggerAt // Only system logic can change this
            && (incoming.status == 'active' || incoming.status == 'suspended')
            && incoming.achievements == existing.achievements // Admin cannot manually change achievements
            && incoming.isAgencyMember == existing.isAgencyMember; // Admin cannot manually change agency status
    }

    /**
     * @description Checks if a user is legitimately triggering the autonomous agent.
     * - Points increase by exactly 10.
     * - Balance and other sensitive fields are unchanged.
     * - Timestamp is updated.
     * - Cooldown of 24 hours is enforced.
     */
    function isTriggeringAgent(incoming, existing) {
        let isCooldownOver = existing.lastMarketingTriggerAt == null || request.time > existing.lastMarketingTriggerAt + duration.time(24, 0, 0, 0);
        return isCooldownOver
            && incoming.points == existing.points + 10
            && incoming.balance == existing.balance
            && incoming.lastMarketingTriggerAt == request.time;
    }

    /**
     * @description Checks if a user is cashing in points for a reward.
     * - User must have enough points (>= 100).
     * - Points decrease by 100.
     * - Balance increases by 5.
     * - Cooldown for agent trigger is also enforced as this happens during an agent trigger.
     */
    function isCashingInPoints(incoming, existing) {
       let isCooldownOver = existing.lastMarketingTriggerAt == null || request.time > existing.lastMarketingTriggerAt + duration.time(24, 0, 0, 0);
       return isCooldownOver
            && (existing.points + 10) >= 100 // Check points before they are incremented
            && incoming.points == existing.points + 10 - 100
            && incoming.balance == existing.balance + 5
            && incoming.lastMarketingTriggerAt == request.time;
    }
    
     /**
     * @description Checks if a user is being debited for creating an ad campaign.
     * - Balance decreases by exactly 2.
     * - Points and other fields are unchanged.
     */
    function isCreatingAdCampaign(incoming, existing) {
      return incoming.balance == existing.balance - 2.00
          && incoming.points == existing.points
          && incoming.lastMarketingTriggerAt == existing.lastMarketingTriggerAt;
    }
    
    /**
     * @description Allows general profile updates (like displayName) that don't affect protected fields.
     */
    function isGeneralProfileUpdate(incoming, existing) {
        return incoming.balance == existing.balance
            && incoming.points == existing.points
            && incoming.lastMarketingTriggerAt == existing.lastMarketingTriggerAt;
    }

    /**
     * @description Validates the structure of an achievement being added.
     */
    function isValidAchievement(achievement) {
      return achievement.id is string
          && achievement.name is string
          && achievement.awardedAt == request.time;
    }

    /**
     * @description Validates that the achievements array is only being added to, not modified.
     * And that only one new achievement is added at a time.
     */
    function isAddingOneValidAchievement(incoming, existing) {
      // Ensure the incoming list is one longer than the existing one
      return incoming.achievements.size() == existing.achievements.size() + 1
          // Ensure all existing achievements are still present at the start of the new list
          && incoming.achievements.slice(0, existing.achievements.size()) == existing.achievements
          // Ensure the newly added achievement has a valid structure
          && isValidAchievement(incoming.achievements[existing.achievements.size()]);
    }
    
    /**
     * @description Validates the data for a new comment.
     */
    function isValidCommentData(data) {
        return data.content is string && data.content.size() > 0 && data.content.size() < 1000
            && data.authorId == request.auth.uid
            && data.authorName == request.auth.token.name
            && data.authorAvatar == request.auth.token.picture
            && data.createdAt == request.time;
    }


    // =================================================================
    //  Collection Rules
    // =================================================================

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     */
    match /users/{userId} {
      // Admins can read any profile. Signed-in users can read public profiles.
      // Users can only read their own full data if not suspended.
      allow get: if (isOwner(userId) && resource.data.status != 'suspended') || isAdmin() || isSignedIn();
      
      // Allow any signed-in user to list users, but the fields they can see are
      // restricted by the `get` rule. Our client-side downline query needs this.
      allow list: if isSignedIn();
      
      // Allow user creation if it's their own document and fields are valid.
      allow create: if isOwner(userId) && hasValidSignupFields();
      
      // Allow updates only under specific, controlled conditions.
      // System-level updates (crediting balance, adding referral earnings) are handled by backend functions with admin privileges
      // and do not go through these client-side rules. These rules are for user-initiated updates.
      allow update: if ( (isOwner(userId) && resource.data.status != 'suspended' && hasAllowedUserUpdates(request.resource.data, resource.data) && (
                          isTriggeringAgent(request.resource.data, resource.data) ||
                          isCashingInPoints(request.resource.data, resource.data) ||
                          isCreatingAdCampaign(request.resource.data, resource.data) ||
                          isGeneralProfileUpdate(request.resource.data, resource.data) ||
                          isAddingOneValidAchievement(request.resource.data, resource.data)
                      )) 
                      || (isAdmin() && hasAllowedAdminUpdates(request.resource.data, resource.data))
                      // Allow a referrer to have an achievement added when someone signs up under them
                      || (exists(/databases/$(database)/documents/users/$(request.resource.data.referredBy)) && isAddingOneValidAchievement(request.resource.data, resource.data))
                    );

      // Only admins can delete users.
      allow delete: if isAdmin();

      /**
       * @description Rules for user's ad campaigns.
       * Users can manage their own campaigns, but not if they are suspended.
       */
      match /campaigns/{campaignId} {
          allow read: if isOwner(userId);
          allow write: if isOwner(userId) && get(/databases/$(database)/documents/users/$(userId)).data.status != 'suspended';
      }
    }
    
    /**
     * @description Collection group query for campaigns.
     * Admins can list all campaigns across all users for the main dashboard view.
     */
    match /{path=**}/campaigns/{campaignId} {
      allow get, list: if isAdmin();
    }


    /**
     * @description Rules for blog posts. Publicly readable, but only admins can write.
     */
    match /posts/{postId} {
      allow read: if true;
      allow write: if isAdmin();
      
      /**
       * @description Rules for comments on a blog post.
       * Anyone signed in can read and create comments.
       * Users can delete their own comments. Admins can delete any comment.
       */
      match /comments/{commentId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.status != 'suspended' && isValidCommentData(request.resource.data);
        allow delete: if (isSignedIn() && isOwner(resource.data.authorId)) || isAdmin();
      }
    }

    /**
     * @description Rules for categories. Public read, admin write.
     */
    match /categories/{categoryId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    /**
     * @description Rules for tags. Public read, admin write.
     */
    match /tags/{tagId} {
      allow read: if true;
      allow write: if isAdmin();
    }

     /**
      * @description Rules for user queries from the smart assistant.
      * Write-only for any authenticated user to protect privacy. No one can read them.
      */
    match /queries/{queryId} {
      allow read, update, delete: if false;
      allow create: if isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.status != 'suspended';
    }
  }
}
